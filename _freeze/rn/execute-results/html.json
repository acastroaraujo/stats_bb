{
  "hash": "ba45d0d96857a8ced17dfc174d9300f5",
  "result": {
    "markdown": "## Generating Random Numbers\n\n-   *How do we simulate random numbers from specific probability distributions?*\n\n-   *How do we use random numbers to do stuff?*\n\nThe simplest case involves generating uniform pseudo-random numbers. ***Methods for generating random numbers from other probability distributions all depend on the uniform random number generator.***\n\nThis set of notes builds upon three black boxes: `runif()`, `sample()`, and `.Random.seed`. It's no use pretending I know how any of this stuff work.\n\nADD SOME STUFF FROM THE BOOK I LOANED NICO.\n\n### `runif()`\n\nADD EXPLANATION OF THIS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunif\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, min = 0, max = 1, log = FALSE) \n.Call(C_dunif, x, min, max, log)\n<bytecode: 0x7ffe5d9e7a08>\n<environment: namespace:stats>\n```\n:::\n\n```{.r .cell-code}\npunif\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) \n.Call(C_punif, q, min, max, lower.tail, log.p)\n<bytecode: 0x7ffe5daf5ff0>\n<environment: namespace:stats>\n```\n:::\n\n```{.r .cell-code}\nqunif\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) \n.Call(C_qunif, p, min, max, lower.tail, log.p)\n<bytecode: 0x7ffe5dc0e768>\n<environment: namespace:stats>\n```\n:::\n\n```{.r .cell-code}\nrunif\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (n, min = 0, max = 1) \n.Call(C_runif, n, min, max)\n<bytecode: 0x7ffe5dd316f8>\n<environment: namespace:stats>\n```\n:::\n:::\n\n\n### `sample()`\n\nR also has a function that allows *sampling from finite populations.* This `sample()` function can be used with our without replacement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## toss six coins\nsample(0:1, size = 6, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 0 0 1 1\n```\n:::\n\n```{.r .cell-code}\n## permuation of letters A-Z\nsample(LETTERS) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"E\" \"J\" \"V\" \"A\" \"M\" \"G\" \"L\" \"S\" \"X\" \"W\" \"B\" \"C\" \"O\" \"R\" \"Y\" \"F\" \"K\" \"N\" \"Q\"\n[20] \"D\" \"I\" \"P\" \"U\" \"Z\" \"T\" \"H\"\n```\n:::\n\n```{.r .cell-code}\n## sample from a multinomial distribution\np <- c(0.2, 0.3, 0.5)\nx <- sample(1:3, size = 3000, replace = TRUE, prob = p)\ntable(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx\n   1    2    3 \n 580  895 1525 \n```\n:::\n\n```{.r .cell-code}\ntable(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx\n        1         2         3 \n0.1933333 0.2983333 0.5083333 \n```\n:::\n:::\n\n\n### `.Random.seed`\n\n*Note. There's an integer vector called `.Random.seed` in the global environment for every R session. This vector changes every time you generate random numbers or every time you change seeds.*\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(111)\nstr(.Random.seed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:626] 10403 624 -762750981 -378653952 -1193945343 -1238812466 800256759 999955148 -1466969763 438919290 ...\n```\n:::\n\n```{.r .cell-code}\nset.seed(222)\nstr(.Random.seed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:626] 10403 624 1488669722 -588037421 -1945880072 -1874066535 1822860934 510535503 495156548 -856964235 ...\n```\n:::\n\n```{.r .cell-code}\nrunif(1) ## generate one random number\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9315925\n```\n:::\n\n```{.r .cell-code}\nstr(.Random.seed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:626] 10403 1 -2033833551 328541280 -1581583874 -1734191735 219878075 -974258550 -1901840020 939491055 ...\n```\n:::\n\n```{.r .cell-code}\nset.seed(111)\nstr(.Random.seed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:626] 10403 624 -762750981 -378653952 -1193945343 -1238812466 800256759 999955148 -1466969763 438919290 ...\n```\n:::\n:::\n\n\n### \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}