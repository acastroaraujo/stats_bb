{
  "hash": "33f3251093dce1cca4b46d1d4f639f4b",
  "result": {
    "markdown": "---\ntitle: \"RCPP\"\neditor: visual\n---\n\n\nThis notebook focuses on converting simple R functions to C++. It barely scratches the surface of what you can do with C++. For more advanced stuff, check out <https://www.learncpp.com/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_three_integers <- function(x1, x2, x3) {\n  x1 + x2 + x3\n}\n\nadd_three_integers(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\nC++\n\n\n::: {.cell}\n\n```{.rcpp .cell-code}\nint add(int x1, int x2, int x3) {\n  int sum = x1 + x2 + x3;\n  return sum;\n}\n```\n:::\n\n\nUsing `Rcpp`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\n\ncppFunction('\nint add(int x, int y, int z) {\n  int sum = x + y + z;\n  return sum;\n}')\n\nadd # works like a regular R function\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, y, z) \n.Call(<pointer: 0x10cbdcf00>, x, y, z)\n```\n:::\n\n```{.r .cell-code}\nadd(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\nNote:\n\n> -   The syntax to create a function looks like the syntax to call a function; you don't use assignment to create functions as you do in R.\n> -   You must declare the type of output the function returns. This function returns an `int` (a scalar integer). The classes for the most common types of R vectors are: `NumericVector`, `IntegerVector`, `CharacterVector`, and `LogicalVector`.\n> -   Scalars and vectors are different. The scalar equivalents of numeric, integer, character, and logical vectors are: `double`, `int`, `String`, and `bool`.\n> -   You must use an explicit `return` statement to return a value from a function.\n> -   Every statement is terminated by a `;`.\n>\n> @wickham2019 [pp. ?]\n\n## Using `Rcpp`\n\n> Typical bottlenecks that C++ can address include:\n>\n> -   Loops that can't be easily vectorised because subsequent iterations depend on previous ones.\n>\n> -   Recursive functions, or problems which involve calling functions millions of times. The overhead of calling a function in C++ is much lower than in R.\n>\n> -   Problems that require advanced data structures and algorithms that R doesn't provide. Through the standard template library (STL), C++ has efficient implementations of many important data structures, from ordered maps to double-ended queues.\n>\n> @wickham2019 [pp. ?]\n\n*Note. C++ is object-oriented in the same way that Python is (i.e., encapsulated OPP); this means we call methods with a \"`.`*\" like this: `object.method()`.\n\n**Three big differences:**\n\n-   In C++, vector indices start at zero!\n\n-   Use `=` for assignment instead of `<-`.\n\n-   The syntax for \"for loops\" is different: `for(init; check; increment) {}`.\n\n    For example, a function that sums all elements in a vector:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    cppFunction(\"\n    double sumC(NumericVector x) {\n      int n = x.size();\n      double result = 0;\n    \n      for (int i = 0; i < n; ++i) {\n        result += x[i];\n      }\n      return result;\n    }\")\n    \n    sum(1:20)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 210\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    sumC(1:20) ## almost as fast!\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 210\n    ```\n    :::\n    :::\n\n\n*Note. There are a few more differences, such as that C++ uses `pow(x, 3)` instead of `x^3`, or that it has modify-in-place operators like `+=`, `-=`*, `*=`, and `/=`.\n\nUsually it's better *not* to use `cppFunction()` and instead source stand-alone files directly using `sourceCPP()`, analogous to R's `source()` function.\n\nStand-alone files should have a `.cpp` extension, analogous to the `.R` extension for regular scripts. Everyone of these files must be structured as follows:\n\n\n::: {.cell}\n\n```{.rcpp .cell-code}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble meanC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n\n  for(int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n  return total / n;\n}\n\n```\n:::\n\n\n### Exercises\n\n> For each of the following functions, read the code and figure out what the corresponding base R function is. You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.\n\n\n::: {.cell}\n\n```{.rcpp .cell-code}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\ndouble f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i < n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i < n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    LogicalVector res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}\n```\n:::\n\n\n*Answer:*\n\n-   `f1` is `mean()`\n\n-   `f2` is `cumsum()`\n\n-   `f3` is `any()`\n\n-   `f4` is `Position()` or `purrr::detect_index()`\n\n-   `f5` is `pmin()`\n\n> To practice your function writing skills, convert the following functions into C++. For now, assume the inputs have no missing values.\n>\n> 1.  [`all()`](https://rdrr.io/r/base/all.html).\n> 2.  [`cumprod()`](https://rdrr.io/r/base/cumsum.html), [`cummin()`](https://rdrr.io/r/base/cumsum.html), [`cummax()`](https://rdrr.io/r/base/cumsum.html).\n> 3.  [`diff()`](https://rdrr.io/r/base/diff.html). Start by assuming lag 1, and then generalize for lag `n`.\n> 4.  [`range()`](https://rdrr.io/r/base/range.html).\n> 5.  [`var()`](https://rdrr.io/r/stats/cor.html). Read about the approaches you can take on [Wikipedia](http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance). Whenever implementing a numerical algorithm, it's always good to check what is already known about the problem.\n\n\n::: {.cell}\n\n```{.rcpp .cell-code}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nbool allC(LogicalVector x) {\n  int n = x.size();\n  \n  for (int i = 0; i < n; ++i) {\n    if (!x[i]) return(false);\n  }\n  return true;\n}\n\n// [[Rcpp::export]]\nNumericVector cumprodC(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n  \n  out[0] = x[0];\n  for (int i = 1; i < n; ++i) {\n    out[i] = out[i-1] * x[i];\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nNumericVector cumminC(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n  \n  out[0] = x[0];\n  for (int i = 1; i < n; ++i) {\n    out[i] = std::min(out[i-1], x[i]);\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nNumericVector cummaxC(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n  \n  out[0] = x[0];\n  for (int i = 1; i < n; ++i) {\n    out[i] = std::max(out[i-1], x[i]);\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nNumericVector diffC(NumericVector x, int lag) {\n  int n = x.size() - lag;\n  NumericVector out(n);\n  \n  if (lag < 1) stop(\"`lag` must be an integer >= 1\");\n  \n  for (int i = 0; i < n; ++i) {\n    out[i] = x[i + lag] - x[i];\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nNumericVector rangeC(NumericVector x) {\n  int n = x.size();\n  double omin = x[0], omax = x[0];\n  \n  for (int i = 1; i < n; ++i) {\n    omin = std::min(omin, x[i]);\n    omax = std::max(omax, x[i]);\n  }\n  \n  NumericVector out(2);\n  out[0] = omin; out[1] = omax;\n  return out;\n  \n}\n\n// [[Rcpp::export]]\ndouble varC(NumericVector x) {\n  int n = x.size();\n  if (n < 2) return NA_REAL;\n  \n  double mu = 0;\n  for (int i = 0; i < n; ++i) mu += x[i];\n  mu /= n;\n  \n  double out = 0;\n  for (int i = 0; i < n; ++i) {\n    out += pow(x[i] - mu, 2);\n  }\n  \n  return out / (n - 1);\n\n}\n```\n:::\n\n\n## Standard Template Library\n\n> The real strength of C++ is revealed when you need to implement more complex algorithms. The standard template library (STL) provides a set of extremely useful data structures and algorithms.\n>\n> @wickham2019 [pp. ?]\n\n**Iterators**\n\n> Iterators are used extensively in the STL: many functions either accept or return iterators. They are the next step up from basic loops, abstracting away the details of the underlying data structure. Iterators have three main operators:\n>\n> 1.  Advance with `++`.\n>\n> 2.  Get the value they refer to, or **dereference**, with `*`.\n>\n> 3.  Compare with `==`.\n>\n> For example we could re-write our sum function using iterators:\n\n\n::: {.cell}\n\n```{.rcpp .cell-code}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum3(NumericVector x) {\n  double total = 0;\n  \n  NumericVector::iterator it;\n  for(it = x.begin(); it != x.end(); ++it) {\n    total += *it;\n  }\n  return total;\n}\n```\n:::\n\n\n> The main changes are in the for loop:\n>\n> -   We start at `x.begin()` and loop until we get to `x.end()`. A small optimization is to store the value of the end iterator so we don\\'t need to look it up each time. This only saves about 2 ns per iteration, so it\\'s only important when the calculations in the loop are very simple.\n>\n> -   Instead of indexing into x, we use the dereference operator to get its current value: `*it`.\n>\n> -   Notice the type of the iterator: `NumericVector::iterator`. Each vector type has its own iterator type: `LogicalVector::iterator`, `CharacterVector::iterator`, etc.\n\n**Data Structures**\n\n> The STL provides a large set of data structures: `array`, `bitset`, `list`, `forward_list`, `map`, `multimap`, `multiset`, `priority_queue`, `queue`, `deque`, `set`, `stack`, `unordered_map`, `unordered_set`, `unordered_multimap`, `unordered_multiset`, and `vector`. The most important of these data structures are the `vector`, the `unordered_set`, and the `unordered_map`.\n\n*Vectors*\n\nMore...\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}